package com.innoz.toolbox.utils.data.kmeans;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

import org.matsim.api.core.v01.Coord;
import org.matsim.api.core.v01.network.Network;
import org.matsim.core.gbl.MatsimRandom;
import org.matsim.core.network.NetworkUtils;
import org.matsim.core.utils.geometry.CoordUtils;

/**
 * 
 * Implementation of the k-means algorithm for spatial clustering.
 * The k-means algorithm usually takes a set of points and a predefined number of clusters and tries to construct these in
 * a way that every points is assigned to a cluster and the coordinates of the point lie closer to the cluster's centroid than
 * to any other cluster's centroid.
 * 
 * @author dhosse
 *
 */
public class Kmeans {

	// MEMBERS //////////////////////////////////
	private int numClusters;
	final double[] boundingBox;
	private List<ClusterPoint> points;
	private List<Cluster> clusters = new ArrayList<>();
	/////////////////////////////////////////////

	/**
	 * Constructor. The number of clusters is set to a default value here (3).
	 * 
	 * @param network The MATsim network defining the boundaries for the algorithm's clusters. Must not be null!
	 */
	public Kmeans(final Network network) {
		
		this(network, 3);
		
	}
	
	/**
	 * Constructor.
	 * 
	 * @param network The MATsim network defining the boundaries for the algorithm's clusters. Must not be null!
	 * @param nClusters The number of clusters that should be generated by the algorithm. Any integer value greater than one.
	 */
	public Kmeans(final Network network, final int nClusters) {
		
		this.boundingBox = NetworkUtils.getBoundingBox(network.getNodes().values());
		this.numClusters = nClusters;
		
	}
	
	/**
	 * 
	 * Set up the basic infrastructure of the algorithm: Assign the points that are to be clustered by the algorithm and set the 
	 * clusters' centroids to initial values.
	 * 
	 * @param points The list of points to be clustered. Must not be empty or null!
	 */
	public void init(final List<ClusterPoint> points) {
		
		// The points passed to the method are the ones to be clustered
		this.points = points;
		
		// Get the random number generator from MATSim
		Random random = MatsimRandom.getRandom();
		
		for(int i = 0; i < this.numClusters; i++) {
			
			Cluster cluster = new Cluster(i);

			// Create random centroids for each cluster
			// There are methods that create the centroids in a more structured way to make the algorithm more efficient.
			// This is the point to add these kind of structures
			double x = this.boundingBox[0] + random.nextDouble() * (this.boundingBox[2] - this.boundingBox[0]);
			double y = this.boundingBox[1] + random.nextDouble() * (this.boundingBox[3] - this.boundingBox[1]);
			ClusterPoint centroid = new ClusterPoint(new Coord(x, y));
			cluster.setCentroid(centroid);
			
			// Add the newly created cluster to the clusters list
			this.clusters.add(cluster);
			
		}
		
	}

	/**
	 * 
	 * The actual calculation / assignment of the points to the clusters. The algorithm runs as long as there are points that
	 * lie closer to another cluster's centroid than the one they were assigned to in the last iteration.
	 * 
	 */
	public void calculate() {
		
		boolean finish = false;

		// While loop runs as long as the termination criterion is not satisfied
		while(!finish) {
			
			// Clear everything that was constructed in the last iteration
			clearClusters();
			// Store the centroids computed in the last iteration for calculation of delta
			List<ClusterPoint> lastCentroids = getCentroids();
			// Assign points to clusters
			assignCluster();
			// Calculate the resulting centroids of this iteration
			calculateCentroids();
			
			List<ClusterPoint> currentCentroids = getCentroids();
			
			// Calculate the difference between the centroids of the last iteration and the ones that were computed in the current
			// one. If delta is equal to 0, the execution stops and the solution is considered stable.
			double delta = 0;
			for(int i = 0; i < lastCentroids.size(); i++) {
				delta += CoordUtils.calcEuclideanDistance(lastCentroids.get(i).getCoord(), currentCentroids.get(i).getCoord());
			}
			// The termination criterion is satisfied -> break
			if(delta == 0) finish = true;
			
		}
		
	}
	
	/**
	 * 
	 * Getter method for the clusters calculated by the k-means algorithm.
	 * 
	 * @return The list of clusters. Its size is equal to the number of clusters defined in the constructor.
	 */
	public List<Cluster> getClusters() {
		
		return this.clusters;
		
	}
	
	/**
	 * 
	 * Clear all points that are stored inside the clusters. This method is called at the start of each iteration.
	 * 
	 */
	private void clearClusters() {
		
		this.clusters.forEach(cluster -> cluster.clear());
		
	}
	
	/**
	 * 
	 * Getter method for the clusters' centroids.
	 * 
	 * @return The list of the clusters' centroids.
	 */
	private List<ClusterPoint> getCentroids() {
		
		return this.clusters.stream().map(Cluster::getCentroid).collect(Collectors.toList());
		
	}
	
	/**
	 * 
	 * Iterates over all points and assigns them to the cluster, the centroid of which lies closest to the points' coordinate.
	 *  
	 */
	private void assignCluster() {
		
		// Initialize the minimum distance (of a point to a cluster's centroid)
		double min = Double.MAX_VALUE;
		// The "index" of the cluster
		int c = 0;
		// the calculated distance between a point and a cluster's centroid
		double distance = 0d;
		
		// Iterate over all points to be clustered
		for(ClusterPoint point : this.points) {
			
			// Re-initialize the minimum distance to the highest value possible
			min = Double.MAX_VALUE;
			
			// Iterate over all clusters
			for(int i = 0; i < numClusters; i++) {
				
				// Calculate the distance between the cluster's centroid and the point's coordinate
				Cluster cluster = this.clusters.get(i);
				distance = CoordUtils.calcEuclideanDistance(point.getCoord(), cluster.getCentroid().getCoord());
				
				// If the distance is less than the current minimum, the point should be inside this cluster
				if(distance < min) {
				
					min = distance;
					c = i;
					
				}
				
			}
			
			// Assign the point to the cluster
			point.setCluster(c);
			this.clusters.get(c).addPoint(point);
			
		}
			
		
	}
	
	/**
	 * 
	 * Calculates the centroids of all clusters based on the points contained in them.
	 * 
	 */
	private void calculateCentroids() {
		
		// Iterate over all clusters
		for(Cluster cluster : this.clusters) {
			
			double sumX = 0d;
			double sumY = 0d;
			
			List<ClusterPoint> points = cluster.getPoints();
			int npoints = points.size();
			
			// Summarize the x and y coordinates...
			for(ClusterPoint point : points) {
				
				sumX += point.getCoord().getX();
				sumY += point.getCoord().getY();
				
			}
			
			ClusterPoint centroid = cluster.getCentroid();
			
			// ...,compute the spatial mean and set the centroid to this value
			if(npoints > 0) {
				
				double newX = sumX / npoints;
				double newY = sumY / npoints;
				
				centroid.setCoord(new Coord(newX, newY));
				
			}
			
		}
		
	}
	
}